<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>爬虫学习路线</title>
    <url>/2020/08/16/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="爬虫学习路线"><a href="#爬虫学习路线" class="headerlink" title="爬虫学习路线"></a>爬虫学习路线</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>更新内容&amp;说明</title>
    <url>/2020/08/14/%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9%E5%8F%8A%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p><strong>由于浏览器缓存等原因，如博客样式出现异常，请刷新页面！！！</strong></p>
<h1 id="2020-08-14"><a href="#2020-08-14" class="headerlink" title="2020-08-14"></a>2020-08-14</h1><p>创建此博客,用于分享自己平时的一些学习笔记及其他文章！</p>
<h1 id="2020-08-15"><a href="#2020-08-15" class="headerlink" title="2020-08-15"></a>2020-08-15</h1><p>更新博客主题（nexT），并进行主题优化！</p>
<h1 id="2020-08-16"><a href="#2020-08-16" class="headerlink" title="2020-08-16"></a>2020-08-16</h1><p>更新python爬虫系列笔记——基础篇！</p>
<h1 id="2020-08-17"><a href="#2020-08-17" class="headerlink" title="2020-08-17"></a>2020-08-17</h1><p>更新Linux（Ubantu）学习笔记！</p>
]]></content>
      <tags>
        <tag>更新说明</tag>
      </tags>
  </entry>
  <entry>
    <title>标签测试2</title>
    <url>/2020/08/17/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%952(%E5%A4%8D%E4%BB%B6)/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>标签1</tag>
      </tags>
  </entry>
  <entry>
    <title>标签测试2</title>
    <url>/2020/08/17/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%952/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>标签1</tag>
      </tags>
  </entry>
  <entry>
    <title>标签测试</title>
    <url>/2020/08/17/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>标签1</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2020/08/17/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Linux学习笔记"><a href="#Linux学习笔记" class="headerlink" title="Linux学习笔记"></a>Linux学习笔记</h1><h2 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h2><h3 id="电脑"><a href="#电脑" class="headerlink" title="电脑"></a>电脑</h3><p><strong>计算机五大单元</strong></p>
<p>输入单元、 输出单元、CPU 内部的控制单元、算数逻辑单元、内存</p>
<p> <strong>电脑分类（按用途）</strong></p>
<ul>
<li><p>超级计算机(Supercomputer) 超级计算机是运行速度最快的电脑,但是他的维护、操作费用也最高!主要是用于需要有高速计算的计划中。 例如:国防军事、气象预测、太空科技,用在仿真的领域较多。</p>
</li>
<li><p>大型计算机(Mainframe Computer) 大型计算机通常也具有数个高速的CPU,功能上虽不及超级计算机,但也可用来处理大量数据与复杂的运算。 例如大型企业的主机、全国性的证券交易所等每天需要处理数百万笔数据的企业机构, 或者是大型企业的数据库服务器等等。</p>
</li>
<li><p>迷你电脑(Minicomputer) 迷你电脑仍保有大型计算机同时支持多使用者的特性,但是主机可以放在一般作业场所, 不必像前两个大型计算机需要特殊的空调场所。通常用来作为科学研究、工程分析与工厂的流程管理等。</p>
</li>
<li><p>工作站(Workstation) 工作站的价格又比迷你电脑便宜许多,是针对特殊用途而设计的电脑。在个人电脑的性能还没有提升到目前的状况之前, 工作站电脑的性能/价格比是所有电脑当中较佳的,因此在学术研究与工程分析方面相当常见。</p>
</li>
<li><p>微电脑(Microcomputer) 个人电脑就属于这部份的电脑分类,也是我们本章主要探讨的目标!体积最小,价格最低,但功能还是五脏俱全的! 大致又可分为桌上型、笔记型等等。</p>
<p><strong>电脑常用的计算单位</strong></p>
</li>
</ul>
<p>​    0/1 这个二进制的的单位我们称为 bit。</p>
<p>​    1 Byte = 8 bits</p>
<p>​    常见的单位与进位制对应关系：</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E4%BD%8D%E4%B8%8E%E8%BF%9B%E4%BD%8D%E5%88%B6%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"></p>
<p>​    一般来说,文件大小使用的是二进制的方式,所以<code>1GBytes</code>的文件大小实际上为:<code>1024x1024x1024Bytes</code>这么大! </p>
<p>速度单位则常使用十进制,例如 <code>1GHz</code>就是<code>1000x1000x1000Hz</code>的意思。网络常使用的单位为 <code>Mbps</code>是<code>Mbits per second</code>,亦即是每秒多少 <code>Mbit</code>    </p>
<h3 id="个人电脑架构"><a href="#个人电脑架构" class="headerlink" title="个人电脑架构"></a>个人电脑架构</h3><h3 id="数据表示方式"><a href="#数据表示方式" class="headerlink" title="数据表示方式"></a>数据表示方式</h3><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="文字模式下指令的下达"><a href="#文字模式下指令的下达" class="headerlink" title="文字模式下指令的下达"></a>文字模式下指令的下达</h3><p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E4%BB%A4%E4%B8%8B%E8%BE%BE.png" alt="文字模式下指令的下达"></p>
<ul>
<li><p>一行指令中第一个输入的部分绝对是“指令(command)”或“可可执行文件案(例如批次脚本,script)”</p>
</li>
<li><p>command 为指令的名称,例如变换工作目录的指令为 <code>cd</code> 等等;</p>
</li>
<li><p>中刮号[]并不存在于实际的指令中,而加入选项设置时,通常选项前会带 - 号,例如 -h;有时候会使用选项的完整全名,则选项前带有 – 符号,例如 –help;</p>
</li>
<li><p><code>parameter1</code> <code>parameter2</code>.. 为依附在选项后面的参数,或者是 command 的参数;</p>
</li>
<li><p>指令, 选项, 参数等这几个咚咚中间以空格来区分,不论空几格 shell 都视为一格。所以空格是很重要的特殊字符;</p>
</li>
<li><p>按下[Enter]按键后,该指令就立即执行。[Enter]按键代表着一行指令的开始启动。</p>
</li>
<li><p>指令太长的时候,可以使用反斜线 (<code>\</code>) 来跳脱[Enter]符号,使指令连续到下一行。</p>
<p>注意：反斜线后就立刻接特殊字符,才能跳脱。</p>
<p> <strong>线上求助</strong>     <code>- -help</code>     <code>man page</code>     <code>info page</code></p>
</li>
</ul>
<p><strong>一些简单命令</strong>  </p>
<p><code>date</code>         显示系统当前时间和日期</p>
<p><code>cal</code>           显示当前月份的日历</p>
<p><code>df</code>            查看磁盘剩余空间的数量</p>
<p><code>free</code>         显示空闲内存的数量</p>
<p><code>su -</code>          root权限</p>
<p><code>cd</code>            变换目录</p>
<p><code>pwd</code>         显示目前所在的目录</p>
<h3 id="Linux-文件权限与目录配置"><a href="#Linux-文件权限与目录配置" class="headerlink" title="Linux 文件权限与目录配置"></a>Linux 文件权限与目录配置</h3><p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="文件属性"></p>
<ul>
<li><p>第一栏 代表这个文件的<strong>类型与权限(permission)</strong></p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9D%83%E9%99%90.png" alt="文件类型与权限"></p>
<ul>
<li>第一个字符 代表这个文件是“目录、文件或链接文件等等”:<ul>
<li>当为[ d ]则是目录,例如上表文件名为<code>“.config”</code>的那一行;</li>
<li>当为[ - ]则是文件,例如上表文件名为<code>“initial-setup-ks.cfg”</code>那一行;</li>
<li>若是[ l ]则表示为链接文件(link file);</li>
<li>若是[ b ]则表示为设备文件里面的可供储存的周边设备(可随机存取设备);</li>
<li>若是[ c ]则表示为设备文件里面的序列埠设备,例如键盘、鼠标(一次性读取设备)。</li>
<li>接下来的字符中,以三个为一组,且均为<code>“rwx”</code> 的三个参数的组合。其中,[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</li>
</ul>
</li>
</ul>
</li>
<li><p>第二栏表示有多少文件名链接到此节点(i-node)</p>
</li>
<li><p>第三栏表示这个文件(或目录)的“拥有者帐号”</p>
</li>
<li><p>第四栏表示这个文件的所属群组</p>
</li>
<li><p>第五栏为这个文件的容量大小,默认单位为Bytes</p>
</li>
<li><p>第六栏为这个文件的创建日期或者是最近的修改日期</p>
</li>
<li><p>第七栏为这个文件的文件名</p>
</li>
</ul>
<h4 id="改变文件属性与权限"><a href="#改变文件属性与权限" class="headerlink" title="改变文件属性与权限"></a>改变文件属性与权限</h4><ul>
<li><p><code>chgrp</code> :改变文件所属群组（要被改变的群组名称必须要在/etc/group文件内存在才行,否则就会显示误）</p>
</li>
<li><p><code>chown</code> :改变文件拥有者（使用者必须是已经存在系统中的帐号,也就是在/etc/passwd 这个文件中有纪录的使用者名称才能改变）</p>
<ul>
<li>如果要连目录下的所有次目录或文件同时更改文件拥有者的话,直接加上 -R 的选项即可</li>
</ul>
</li>
<li><p><code>chmod</code> :改变文件的权限, SUID, SGID, SBIT等等的特性</p>
<ul>
<li><p>数字类型改变文件权限</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/chmod%E8%AF%AD%E6%B3%95.png" alt="chmod语法"></p>
<p>各权限的==分数==对照表如下:        r:4 &gt; w:2 &gt; x:1</p>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要==累加==的</p>
</li>
</ul>
</li>
<li><p>符号类型改变文件权限</p>
<ul>
<li><p>user 、group 、others三种身份啦由u, g, o来代表三种身份的权限。此外, a 则代表 all 亦即全部的身份。</p>
</li>
<li><p><code>| chmod | u g o a | +(加入) -(除去) =(设置) | r w x | 文件或目录 |</code></p>
<p>例如：<code>chmod u=rwx,go=rx .bashrc</code></p>
<p>​                user (u):具有可读、可写、可执行的权限<br>​                group 与 others (g/o):具有可读与执行的权限</p>
</li>
</ul>
</li>
</ul>
<h4 id="文件种类与拓展名"><a href="#文件种类与拓展名" class="headerlink" title="文件种类与拓展名"></a>文件种类与拓展名</h4><p><strong>文件种类</strong></p>
<ul>
<li><p><strong>正规文件(regular file )</strong>: 就是一般我们在进行存取的类型的文件,在由 ls -al 所显示出来的属性方面</p>
<p>​        依照文件的内容,又大略可以分为：</p>
<ul>
<li>纯文本文件(ASCII)</li>
<li>二进制档(binary)</li>
<li>数据格式文件(data)</li>
</ul>
</li>
<li><p><strong>目录(directory)</strong></p>
</li>
<li><p><strong>链接文件(link)</strong>: 就是类似Windows系统下面的捷径</p>
</li>
<li><p><strong>设备与设备文件(device)</strong>: 与系统周边及储存等相关的一些文件, 通常都集中在/dev这个目录之下</p>
<p>​        通常又分为两种：</p>
<ul>
<li>区块(block)设备文件 :就是一些储存数据, 以提供系统随机存取的周边设备,例如：硬盘与软盘等。你可以随机的在硬盘的不同区块读写,这种设备就是区块设备，第一个属性为[ b ]。</li>
<li>字符(character)设备文件:亦即是一些序列埠的周边设备, 例如键盘、鼠标等等。这些设备的特色就是“一次性读取”的,不能够截断输出。第一个属性为 [ c ]。</li>
</ul>
</li>
<li><p><strong>数据接口文件(sockets)</strong>: 这种类型的文件通常被用在网络上的数据承接。我们可以启动一个程序来监听用户端的要求, 而用户端就可以通过这个socket来进行数据的沟通了。第一个属性为 [ s ], 最常在/run或/tmp这些个目录中看到这种文件类型了。</p>
</li>
<li><p><strong>数据输送档(FIFO, pipe)</strong>: FIFO也是一种特殊的文件类型,他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[p] 。</p>
</li>
</ul>
<p><strong>Linux文件扩展名</strong></p>
<p>​    基本上,Linux的文件是没有所谓的“扩展名”的。一个Linux文件能不能被执行,与他的第一栏的十个属性有关, 与文件名根本一点关系也没有。</p>
<p>​    通常我们还是会以适当的扩展名来表示该文件是什么种类的</p>
<ul>
<li>*.sh : 脚本或批处理文件 (scripts),因为批处理文件为使用shell写成的,所以扩展名就编成 .sh </li>
<li>Z, .tar, .tar.gz, .zip, *.tgz: 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar等等的,由于不同的压缩软件,而取其相关的扩展名</li>
<li>.html, .php:网页相关文件,分别代表 HTML 语法与 PHP 语法的网页文件。.html 的文件可使用网页浏览器来直接打开,    .php 的文件, 则可以通过 client 端的浏览器来server 端浏览,以得到运算后的网页结果</li>
</ul>
<h4 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h4><p>**Filesystem Hierarchy Standard (FHS)**—Linux目录配置的依据</p>
<p>FHS针对目录树架构定义出三层目录下面应该放置什么数据:</p>
<ul>
<li><p>/ (root, 根目录):与开机系统有关</p>
</li>
<li><p>/usr (unix software resource):与软件安装/执行有关</p>
</li>
<li><p>/var (variable):与系统运行过程有关</p>
<ul>
<li><p>根目录 (/) 的意义与内容</p>
<ul>
<li><p>根目录是整个系统最重要的一个目录,因为不但所有的目录都是由根目录衍生出来的,同时根目录也与开机/还原/系统修复等动作有关</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>第一部份:FHS要求必须要存在的目录</td>
<td></td>
</tr>
<tr>
<td>/bin</td>
<td>系统有很多放置可执行文件的目录,但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin下面的指令可以被root与一般帐号所使用,主要有:cat, chmod, chown, date, mv, mkdir, cp, bash等等常&lt;用的指令。</td>
</tr>
<tr>
<td>/boot</td>
<td>这个目录主要在放置开机会使用到的文件,包括Linux核心文件以及开机菜单与开机所需配置文件等等。 Linux kernel常用的文件为:vmlinuz,如果使用的是grub2这个开机管理程序, 则还会存在/boot/grub2/这个目录喔!</td>
</tr>
<tr>
<td>/dev</td>
<td>在Linux系统上,任何设备与周边设备都是以文件的型态存在于这个目录当中的。 你只要通过存取这个目录下面的某个文件,就等于存取某个设备啰~ 比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/loop, /dev/sd等等</td>
</tr>
<tr>
<td>/etc</td>
<td>系统主要的配置文件几乎都放置在这个目录内,例如人员的帐号密码档、各种服务的启始档等等。一般来说,这个目录下的各文件属性是可以让一般使用者查阅的, 但是只有root有权力修改。FHS建议不要放置可可执行文件(binary)在这个目录中喔。比较重要的文件有: /etc/modprobe.d/,/etc/passwd, /etc/fstab, /etc/issue 等等。另外 FHS 还规范几个重要的目录最好要存在 /etc/ 目录下喔:/etc/opt(必要):这个目录在放置第三方协力软件 /opt 的相关配置文件 /etc/X11/(建议):与 X Window 有关的各种配置文件都在这里,尤其是 xorg.conf 这个 X Server 的配置文件。 /etc/sgml/(建议):与 SGML 格式有关的各项配置文件 /etc/xml/(建议):与 XML格式有关的各项配置文件</td>
</tr>
<tr>
<td>/lib</td>
<td>系统的函数库非常的多,而/lib放置的则是在开机时会用到的函数库, 以及在/bin或/sbin下面的指令会调用的函数库而已。 什么是函数库呢?你可以将他想成是“外挂”,某些指令必须要有这些“外挂”才能够顺利完成程序的执行之意。 另外 FSH 还要求下面的目录必须要存在:/lib/modules/:这个目录主要放置可抽换式的核心相关模块(驱动程序)喔!</td>
</tr>
<tr>
<td>/media</td>
<td>media是“媒体”的英文,顾名思义,这个/media下面放置的就是可移除的设备啦! 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名有:/media/floppy, /media/cdrom等等。</td>
</tr>
<tr>
<td>/mnt</td>
<td>如果你想要暂时挂载某些额外的设备,一般建议你可以放置到这个目录中。在古早时候,这个目录的用途与/media相同啦!只是有了/media之后,这个目录就用来暂时挂载用了。</td>
</tr>
<tr>
<td>/opt</td>
<td>这个是给第三方协力软件放置的目录。什么是第三方协力软件啊? 举例来说,KDE这个桌面管理系统是一个独立的计划,不过他可以安装到Linux系统中,因此KDE的软件就建议放置到此目录下了。 另外,如果你想要自行安装额外的软件(非原本的distribution提供的),那么也能够将你的软件安装到这里来。 不过,以前的Linux系统中,我们还是习惯放在/usr/local目录下呢!</td>
</tr>
<tr>
<td>/run</td>
<td>早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下,新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真,因此性能上会好很多!</td>
</tr>
<tr>
<td></td>
<td>Linux有非常多指令是用来设置系统环境的,这些指令只有root才能够利用来“设置”系统,其他使用者最多只能用来“查询”而已。 放在/sbin下面的为开机过程中所需要的,里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序,一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件(system binary), 则放置到/usr/local/sbin/当中了。常见的指令包括:fdisk, fsck, ifconfig, mkfs等等。</td>
</tr>
<tr>
<td>/srv</td>
<td>srv可以视为“service”的缩写,是一些网络服务启动之后,这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说,WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过,系统的服务数据如果尚未要提供给网际网络任何人浏览的话,默认还是建议放置到 /var/lib下面即可。</td>
</tr>
<tr>
<td>/tmp</td>
<td>这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的,所以你需要定期的清理一下。当然,重要数据不可放置在此目录啊! 因为FHS甚至建议在开机时,应该要将/tmp下的数据都删除唷!</td>
</tr>
<tr>
<td>/usr</td>
<td>第二层 FHS 设置,后续介绍</td>
</tr>
<tr>
<td>/var</td>
<td>第二层 FHS 设置,主要为放置变动性的数据,后续介绍</td>
</tr>
<tr>
<td>第二部份:FHS建议可以存在的目录</td>
<td></td>
</tr>
<tr>
<td>/home</td>
<td>这是系统默认的使用者主文件夹(home directory)。在你新增一个一般使用者帐号时, 默认的使用者主文件夹都会规范到这里来。比较重要的是,主文件夹有两种代号喔:~:代表目前这个使用者的主文件夹   ~zpy :则代表 zpy的主文件夹!</td>
</tr>
<tr>
<td>/lib<code>&lt;qual&gt;</code></td>
<td>用来存放与 /lib 不同的格式的二进制函数库,例如支持 64 位的 /lib64 函数库等</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员(root)的主文件夹。之所以放在这里,是因为如果进入单人维护模式而仅挂载根目录时, 该目录就能够拥有root的主文件夹,所以我们会希望root的主文件夹与根目录放置在同一个分区中。</td>
</tr>
</tbody></table>
<p>另外，在Linux当中非常重要的目录</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>/lost+found</td>
<td>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录,目的在于当文件系统发生错误时, 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话,就不会存在这个目录了!</td>
</tr>
<tr>
<td>/proc</td>
<td>这个目录本身是一个“虚拟文件系统(virtual filesystem)”喔!他放置的数据都是在内存当中, 例如系统核心、行程信息(process)、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中, 所以本身不占任何硬盘空间啊!比较重要的文件例如:/proc/cpuinfo, /proc/dma,/proc/interrupts, /proc/ioports, /proc/net/* 等等。</td>
</tr>
<tr>
<td>/sys</td>
<td>这个目录其实跟/proc非常类似,也是一个虚拟的文件系统,主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔!</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>/usr 的意义与内容</p>
<ul>
<li><p>/usr里面放置的数据属于可分享的与不可变动的(shareable,static)</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>第一部份:FHS 要求必须要存在的目录</td>
<td></td>
</tr>
<tr>
<td>/usr/bin/</td>
<td>所有一般用户能够使用的指令都放在这里!目前新的 CentOS 7 已经将全部的使用者指令放置于此,而使用链接文件的方式将 /bin 链接至此!也就是说, /usr/bin 与 /bin 是一模一样了!另外,FHS 要求在此目录下不应该有子目录!</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>基本上,与 /lib 功能相同,所以 /lib 就是链接到此目录中的!</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>系统管理员在本机自行安装自己下载的软件(非distribution默认提供者),建议安装到此目录, 这样会比较便于管理。举例来说,你的distribution提供的软件较旧,你想安装较新的软件但又不想移除旧版,此时你可以将新版软件安装于/usr/local/目录下,可与原先的旧版软件有分别啦! 你可以自行到/usr/local去看看,该目录下也是具有bin, etc,include, lib…的次目录喔!</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)啰!不过基本功能与 /sbin 也差不多, 因此目前 /sbin 就是链接到此目录中的。</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>主要放置只读架构的数据文件,当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据, 因为几乎都是文字文件嘛!在此目录下常见的还有这些次目录:/usr/share/man:线上说明文档 /usr/share/doc:软件杂项的文件说明 /usr/share/zoneinfo:与时区有关的时区文件</td>
</tr>
<tr>
<td>第二部份:FHS 建议可以存在的目录</td>
<td></td>
</tr>
<tr>
<td>/usr/games/</td>
<td>与游戏比较相关的数据放置处</td>
</tr>
<tr>
<td>/usr/include/</td>
<td>c/c++等程序语言的文件开始(header)与包含档(include)放置处,当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时,会使用到里头的许多包含档喔!</td>
</tr>
<tr>
<td>/usr/libexec/</td>
<td>某些不被一般使用者惯用的可执行文件或脚本(script)等等,都会放置在此目录中。例如大部分的 X 窗口下面的操作指令, 很多都是放在此目录下的。</td>
</tr>
<tr>
<td>/usr/lib<code>&lt;qual&gt;</code>/</td>
<td>与 /lib<qual>/功能相同,因此目前 /lib<qual> 就是链接到此目录中</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>一般源代码建议放置到这里,src有source的意思。至于核心源代码则建议放置到/usr/src/linux/目录下。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>/var 的意义与内容</p>
<ul>
<li><p>如果/usr是安装时会占用较大硬盘容量的目录,那么/var就是在系统运行后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件,包括高速缓存(cache)、登录文件(log file)以及某些软件运行所产生的文件, 包括程序文件(lock file, run file),或者例如MySQL数据库的文件等</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置文件内容</th>
</tr>
</thead>
<tbody><tr>
<td>第一部份:FHS要求必须要存在的目录</td>
<td></td>
</tr>
<tr>
<td>/var/cache/</td>
<td>应用程序本身运行过程中会产生的一些暂存盘;</td>
</tr>
<tr>
<td>/var/lib/</td>
<td>程序本身执行的过程中,需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说,MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去!</td>
</tr>
<tr>
<td>/var/lock/</td>
<td>某些设备或者是文件资源一次只能被一个应用程序所使用,如果同时有两个程序使用该设备时, 就可能产生一些错误的状况,因此就得要将该设备上锁(lock),以确保该设备只会给单一软件所使用。 举例来说,烧录机正在烧录一块光盘,你想一下,会不会有两个人同时在使用一个烧录机烧片? 如果两个人同时烧录,那片子写入的是谁的数据?所以当第一个人在烧录时该烧录机就会被上锁, 第二个人就得要该设备被解除锁定(就是前一个人用完了)才能够继续使用啰。目前此目录也已经挪到 /run/lock 中!</td>
</tr>
<tr>
<td>/var/log/</td>
<td>重要到不行!这是登录文件放置的目录!里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登陆者的信息)等。</td>
</tr>
<tr>
<td>/var/mail/</td>
<td>放置个人电子邮件信箱的目录,不过这个目录也被放置到/var/spool/mail/目录中! 通常这两个目录是互为链接文件啦!</td>
</tr>
<tr>
<td>/var/run/</td>
<td>某些程序或者是服务启动后,会将他们的PID放置在这个目录下喔。 与 /run 相同,这个目录链接到 /run去了!</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>这个目录通常放置一些伫列数据,所谓的“伫列”就是排队等待其他程序使用的数据啦! 这些数据被使用后通常都会被删除。举例来说,系统收到新信会放置到/var/spool/mail/中, 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中, 等到被送出后就被删除。如果是工作调度数据(crontab),就会被放置到/var/spool/cron/目录中!</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><ul>
<li><strong>绝对路径</strong>:由根目录(/)开始写起的文件名或目录名称, 例如 /home/dmtsai/.bashrc;</li>
<li><strong>相对路径</strong>:相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等<br>等。反正开头不是 / 就属于相对路径的写法</li>
</ul>
<h3 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h3><h4 id="特殊的目录"><a href="#特殊的目录" class="headerlink" title="特殊的目录"></a>特殊的目录</h4><p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%B9%E6%AE%8A%E7%9A%84%E7%9B%AE%E5%BD%95.png" alt="特殊的目录"></p>
<p>常见的处理目录的指令：</p>
<ul>
<li>cd:变换目录</li>
<li>pwd:显示目前的目录</li>
<li>mkdir:创建一个新的目录</li>
<li>rmdir:删除一个空的目录</li>
<li>cd (change directory, 变换目录)</li>
</ul>
<h4 id="关于可执行文件路径的变量-PATH"><a href="#关于可执行文件路径的变量-PATH" class="headerlink" title="关于可执行文件路径的变量: $PATH"></a>关于可执行文件路径的变量: $PATH</h4><ul>
<li>echo $PATH： 查看PATH</li>
<li>PATH=”${PATH}:/目录名”：添加PATH</li>
</ul>
<h4 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h4><p>​        文件与目录的检视: ls</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E8%A7%86.png" alt="ls"></p>
<p>​        复制、删除与移动: cp, rm, mv</p>
<p>​        cp (复制文件或目录)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cp.png" alt="cp"></p>
<p>​        rm (移除文件或目录)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rm.png" alt="rm"></p>
<p>​            mv (移动文件与目录,或更名)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mv.png" alt="mv"></p>
<h4 id="取得路径的文件名称与目录名称"><a href="#取得路径的文件名称与目录名称" class="headerlink" title="取得路径的文件名称与目录名称"></a>取得路径的文件名称与目录名称</h4><p><code>basename</code>     <code>dirname</code></p>
<h4 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h4><ul>
<li>cat 由第一行开始显示文件内容</li>
</ul>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cat.png" alt="cat"></p>
<ul>
<li>tac 从最后一行开始显示,可以看出 tac 是 cat 的倒着写</li>
</ul>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/tac.png" alt="tac"></p>
<ul>
<li>nl 显示的时候,顺道输出行号</li>
</ul>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/nl.png" alt="nl"></p>
<ul>
<li><p>more 一页一页的显示文件内容</p>
<ul>
<li>空白键 (space):代表向下翻一页;</li>
<li>Enter :代表向下翻“一行”;</li>
<li>/字串 :代表在这个显示的内容当中,向下搜寻“字串”这个关键字;</li>
<li>:f :立刻显示出文件名以及目前显示的行数;</li>
<li>q :代表立刻离开 more ,不再显示该文件内容。</li>
<li>b 或 [ctrl]-b :代表往回翻页,不过这动作只对文件有用,对管线无用</li>
</ul>
</li>
<li><p>less 与 more 类似,但是比 more 更好的是,他可以往前翻页</p>
<ul>
<li>空白键 :向下翻动一页</li>
<li>pagedown:向下翻动一页;</li>
<li>pageup:向上翻动一页;</li>
<li>/字串 :向下搜寻“字串”的功能;</li>
<li>?字串 :向上搜寻“字串”的功能;</li>
<li>n :重复前一个搜寻 (与 / 或 ? 有关!)</li>
<li>N :反向的重复前一个搜寻 (与 / 或 ? 有关!)</li>
<li>g :前进到这个数据的第一行去;</li>
<li>G :前进到这个数据的最后一行去 (注意大小写);</li>
<li>q :离开 less 这个程序;</li>
</ul>
</li>
<li><p>head 只看头几行</p>
</li>
<li><p>tail 只看尾巴几行</p>
</li>
<li><p>od 以二进制的方式读取文件内容</p>
</li>
</ul>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/od.png" alt="od"></p>
<h4 id="修改文件时间或创建新文件-touch"><a href="#修改文件时间或创建新文件-touch" class="headerlink" title="修改文件时间或创建新文件: touch"></a>修改文件时间或创建新文件: touch</h4><p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/touch.png" alt="touch"></p>
<h4 id="文件默认权限"><a href="#文件默认权限" class="headerlink" title="文件默认权限"></a>文件默认权限</h4><p><strong>umask</strong>(目前使用者在创建文件或目录时候的权限默认值)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/umask.png" alt="umask"></p>
<h4 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h4><p>chattr (设置文件隐藏属性)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/chattr.png" alt="chattr"></p>
<p>lsattr (显示文件隐藏属性)</p>
<p><img src="https://gitee.com/zhengpingyang/image/raw/master/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lsattr.png" alt="lsattr"></p>
<h4 id="文件特殊权限-SUID-SGID-SBIT"><a href="#文件特殊权限-SUID-SGID-SBIT" class="headerlink" title="文件特殊权限: SUID, SGID, SBIT"></a>文件特殊权限: SUID, SGID, SBIT</h4><h4 id="观察文件类型-file"><a href="#观察文件类型-file" class="headerlink" title="观察文件类型:file"></a>观察文件类型:file</h4><h4 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h4><h3 id="Linux-磁盘与文件系统管理"><a href="#Linux-磁盘与文件系统管理" class="headerlink" title="Linux 磁盘与文件系统管理"></a>Linux 磁盘与文件系统管理</h3><h3 id="文件与文件系统的压缩-打包与备份"><a href="#文件与文件系统的压缩-打包与备份" class="headerlink" title="文件与文件系统的压缩,打包与备份"></a>文件与文件系统的压缩,打包与备份</h3><h3 id="vim-程序编辑器"><a href="#vim-程序编辑器" class="headerlink" title="vim 程序编辑器"></a>vim 程序编辑器</h3><h3 id="认识与学习BASH"><a href="#认识与学习BASH" class="headerlink" title="认识与学习BASH"></a>认识与学习BASH</h3><h3 id="正则表达式与文件格式化处理"><a href="#正则表达式与文件格式化处理" class="headerlink" title="正则表达式与文件格式化处理"></a>正则表达式与文件格式化处理</h3><h3 id="学习-Shell-Scripts"><a href="#学习-Shell-Scripts" class="headerlink" title="学习 Shell Scripts"></a>学习 Shell Scripts</h3><h3 id="Linux-帐号管理与-ACL-权限设置"><a href="#Linux-帐号管理与-ACL-权限设置" class="headerlink" title="Linux 帐号管理与 ACL 权限设置"></a>Linux 帐号管理与 ACL 权限设置</h3><h3 id="磁盘配额-Quota-与进阶文件系统管理"><a href="#磁盘配额-Quota-与进阶文件系统管理" class="headerlink" title="磁盘配额(Quota)与进阶文件系统管理"></a>磁盘配额(Quota)与进阶文件系统管理</h3><h3 id="例行性工作调度-crontab"><a href="#例行性工作调度-crontab" class="headerlink" title="例行性工作调度(crontab)"></a>例行性工作调度(crontab)</h3><h3 id="程序管理与-SELinux-初探"><a href="#程序管理与-SELinux-初探" class="headerlink" title="程序管理与 SELinux 初探"></a>程序管理与 SELinux 初探</h3><h3 id="认识系统服务-daemons"><a href="#认识系统服务-daemons" class="headerlink" title="认识系统服务 (daemons)"></a>认识系统服务 (daemons)</h3><h3 id="认识与分析登录文件"><a href="#认识与分析登录文件" class="headerlink" title="认识与分析登录文件"></a>认识与分析登录文件</h3><h3 id="开机流程、模块管理与-Loader"><a href="#开机流程、模块管理与-Loader" class="headerlink" title="开机流程、模块管理与 Loader"></a>开机流程、模块管理与 Loader</h3><h3 id="基础系统设置与备份策略"><a href="#基础系统设置与备份策略" class="headerlink" title="基础系统设置与备份策略"></a>基础系统设置与备份策略</h3><h3 id="软件安装-源代码与-Tarball"><a href="#软件安装-源代码与-Tarball" class="headerlink" title="软件安装:源代码与 Tarball"></a>软件安装:源代码与 Tarball</h3><h3 id="软件安装-RPM-SRPM-与-YUM"><a href="#软件安装-RPM-SRPM-与-YUM" class="headerlink" title="软件安装 RPM, SRPM 与 YUM"></a>软件安装 RPM, SRPM 与 YUM</h3><h3 id="X-Window-设置介绍"><a href="#X-Window-设置介绍" class="headerlink" title="X Window 设置介绍"></a>X Window 设置介绍</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记——基础篇（三）</title>
    <url>/2020/08/16/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="爬虫学习笔记"><a href="#爬虫学习笔记" class="headerlink" title="爬虫学习笔记"></a>爬虫学习笔记</h1><h2 id="第三章-数据文件处理"><a href="#第三章-数据文件处理" class="headerlink" title="第三章 数据文件处理"></a>第三章 数据文件处理</h2><h3 id="一-json文件处理"><a href="#一-json文件处理" class="headerlink" title="一. json文件处理"></a>一. json文件处理</h3><ol>
<li><p><strong>JSON支持的数据格式：</strong></p>
<ul>
<li>对象(字典)： { }</li>
<li>数组(列表)： [ ]</li>
<li>整形，浮点型 </li>
<li>字符串类型，字符串必须要<font color='red'>双引号</font></li>
<li>多个数据之间使用逗号分开</li>
</ul>
</li>
</ol>
<p><strong>注意：JSON本质上就是一个字符串</strong></p>
<ol start="2">
<li><p>字典,列表,JSON字符串，JSON文件相互转换 （加了”s”和文件没关系，不加”s”和文件有关系）<br>主要用：dump,dumps,load,loads .</p>
<p><code>json.dump</code>：将json字符串写入文件中。注意，如果json字符中存在汉字，需要在打开文件的时候使用 <code>encoding=&#39;utf-8&#39;</code> 命令，以及在 <code>json.dump</code> 中设置 <code>ensure_ascii=False</code> 参数</p>
<p><code>json.dumps</code>：将python的字典、列表或字符串转换为json字符串。在python中，只有基本数据类型才能转换为json格式的字符串，即 <code>int</code>、<code>float</code>、<code>str</code>、<code>list</code>、<code>dict</code> 和 <code>turple</code></p>
<p><code>json.load</code>：读取json文件的内容，转换为列表。注意，如果json文件中包含汉字，需要在打开文件的时候使用 <code>encoding=&#39;utf-8&#39;</code> 命令</p>
<p><code>json.loads</code>：将json字符串转换为python的字典、列表或字符串</p>
</li>
</ol>
<h3 id="二-CSV文件处理："><a href="#二-CSV文件处理：" class="headerlink" title="二. CSV文件处理："></a>二. CSV文件处理：</h3><ol>
<li><p>CSV文件介绍</p>
<ol>
<li>纯文本，使用某个字符集等</li>
<li>由记录组成</li>
<li>每条记录被分隔符分割为字段（逗号，分号，空格，制表符）</li>
<li>每条记录都有同样的字段序列</li>
</ol>
</li>
<li><p>CSV读写操作：</p>
<p><strong>读取csv文件需要引入 <code>csv</code> 库</strong></p>
<p>两种读取 <code>csv</code> 文件的方法：</p>
<p>​    <code>with open(&#39;xxx.csv&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f</code> 代码可以准确读取 <code>csv</code> 文件中的中文</p>
<ol>
<li><p><code>reader = csv.reader(f)</code> ：</p>
<p><code>reader</code> 是一个迭代器，遍历 <code>reader</code> 每次返回一个列表。通过 <code>next(reader)</code> 命令可以去除 <code>reader</code> 迭代器的第 <code>0</code> 行，从第 <code>1</code> 行开始遍历。使用下标的方式获取对应的值，若 <code>csv</code> 文件结构发生改变，则获取的值发生改变，<font color='red'>不推荐</font></p>
</li>
<li><p><code>reader = csv.DictReader(f)</code></p>
<p><code>reader</code> 是一个迭代器，遍历 <code>reader</code> 每次返回一个有序字典。通过 <code>dict[&#39;key&#39;]</code> 命令获得对应的值，即使 <code>csv</code> 文件结构发生改变，获取的值也不会改变，推荐<font color='red'>使用这种方法</font></p>
</li>
</ol>
<p>两种写入 <code>csv</code> 文件的方法：</p>
<p>​    <code>with open(&#39;xxx.csv&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as f</code> 代码可以准确地将中文写入 <code>csv</code> 文件中， <code>newline=&#39;&#39;</code> 参数表示写入的每一行之间不需要空行，默认是 <code>\n</code>，即写入一行空一行</p>
<ol>
<li><p>以行的方式写入。<code>writerow</code> 表示每次写入一行，<code>writerows</code> 表示每次写入多行。这种写入方式的优点是<font color='red'>简单</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = csv.writer(f)</span><br><span class="line">writer.writerow(monorow)</span><br><span class="line">writer.writerows(multirows)</span><br></pre></td></tr></table></figure>
</li>
<li><p>以字典的方式写入。注意，写入表头数据的时候，需要调用 <code>writeheader</code> 方法，表头不会自动写入。这种写入方式的优点是<font color='red'>准确</font>，即使写入的字典内数据的顺序发生改变，只要键值对依然正确，就可以按照表头的顺序正确写入数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = csv.DictWriter(f, headers)</span><br><span class="line">writer.writerheader()</span><br><span class="line">writer.writerows(multirows)</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫学习笔记——基础篇（二）</title>
    <url>/2020/08/16/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="爬虫学习笔记"><a href="#爬虫学习笔记" class="headerlink" title="爬虫学习笔记"></a>爬虫学习笔记</h1><h2 id="第二章-数据提取"><a href="#第二章-数据提取" class="headerlink" title="第二章 数据提取"></a>第二章 数据提取</h2><h3 id="一-XPath-语法和lxml模块"><a href="#一-XPath-语法和lxml模块" class="headerlink" title="一. XPath 语法和lxml模块"></a>一. XPath 语法和lxml模块</h3><p>xpath:(XML Path Language) 是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历<br>xpath 开发工具：<br>    chrome插件 xpath Helper<br>    firefox插件 try xpath</p>
<ul>
<li><p>XPath 语法：</p>
<ol>
<li>选取节点：<br>XPath使用路径表达式来选取XML文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似</li>
</ol>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td>选取此节点的所有子节点</td>
<td>bookstore</td>
<td>选取bookstore下所有的子节点</td>
</tr>
<tr>
<td align="center">/</td>
<td>如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点</td>
<td>/bookstore</td>
<td>选取根元素下所有的bookstore节点</td>
</tr>
<tr>
<td align="center">//</td>
<td>从全局节点中选取节点，随便在哪个位置</td>
<td>//book</td>
<td>从全局节点中找到所有的book节点</td>
</tr>
<tr>
<td align="center">@</td>
<td>选取某个节点的属性</td>
<td>//book[@price]</td>
<td>选取所有拥有price属性的book节点</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>谓语：</p>
<p>谓语<strong>用来查找某个特定节点或者包含某个指定的值的节点</strong>，被嵌在方括号中。<br>下面的表格中，列出了带有位于的一些路径表达式以及表达式的结果</p>
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/bookstore/book[1]</td>
<td>选取bookstore下的第一个子元素（下标从1开始）</td>
</tr>
<tr>
<td>/bookstore/book[last()]</td>
<td>选取bookstore下的倒数第二个book元素</td>
</tr>
<tr>
<td>bookstore/book[position()&lt;3]</td>
<td>选取bookstore下前面两个子元素</td>
</tr>
<tr>
<td>//book[@price]</td>
<td>选取拥有price属性的book元素</td>
</tr>
<tr>
<td>//book[@price=10]</td>
<td>选取所有属性price等于10的book元素</td>
</tr>
</tbody></table>
</li>
<li><p>通配符<br>*表示通配符</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配任意节点</td>
<td>/bookstore/*</td>
<td>选取bookstore下的所有子元素</td>
</tr>
<tr>
<td>@*</td>
<td>匹配节点中的任何属性</td>
<td>//book[@*]</td>
<td>选取带有属性的book元素</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑</p>
<p>|  &amp;  +  -  mod等等</p>
</li>
</ol>
</li>
</ul>
<pre><code>总结： 

* 注意/ 和// 的区别。是子节点和全部节点。 // 获取子孙节点。一般//用的多
* contains：有时候某个属性中包含了多个值，那么可以通过contains函数：
    例如：`//div[contains(@class, &quot;job_detail&quot;)]`
* 谓词下标是从1开始的</code></pre>
<ul>
<li><p><strong>lxml库</strong></p>
<p>使用lxml解析HTML代码：</p>
<ol>
<li><p>解析html字符串，使用<code>lxml.etree.HTML</code>进行解析。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">htmlElement = etree.HTML(text)</span><br><span class="line">print(etree.tostring(htmlElement, encoding=<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析html文件。使用<code>lxml.etree.parse</code>进行解析。<br>注意，当文件中的html不规范的时候，注意更换解析器为HTMLParser。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = etree.HTMLParser(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">htmlElement = etree.parse(<span class="string">&quot;tencent.html&quot;</span>, parser=parser)</span><br><span class="line">print(etree.tostring(htmlElement, encoding=<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li>lxml与XPath结合运用：<br>详见代码10</li>
</ul>
<h3 id="二-BeautifulSoup4库"><a href="#二-BeautifulSoup4库" class="headerlink" title="二. BeautifulSoup4库"></a>二. BeautifulSoup4库</h3><p>和lxml一样，BeautifuSoup也是一个HTML/XML的解析器。主要的功能也是如何解析和提取HTML/XML数据<br>lxml只会局部遍历。而BeautifulSoup是基于HTML DOM()的。会载入整个文档。解析整个DOM树，因此时间和内存开销大，性能低于lxml<br>但是非常简单。支持CSS选择器。和诸多解析器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span>  bs4 <span class="keyword">import</span> BeautifuSoup</span><br></pre></td></tr></table></figure>

<p>TIPS：    .prettify()       以更美观的方式打印</p>
<p><strong>TIPS :</strong><br><strong>string, strings, stripper_strings属性以及get_text方法：</strong></p>
<ol>
<li>string：获取某个标签下的非标签字符串。返回来的是个字符串。<font color='red'>如果字符有多行，则无法获得全部字符。</font></li>
<li>strings: 获取某个标签下的子孙非标签字符串。返回来的是一个生成器</li>
<li>stripper_strings: 获取某个标签下的子孙非标签字符串。会去掉空白字符。返回来的是一个生成器</li>
<li>get_text :获取某个标签下的子孙非标签字符串。不是以列表的形式返回，是以普通字符串返回</li>
</ol>
<p><strong>搜索文档树</strong></p>
<ol>
<li><p><strong>find和find_all 方法：</strong><br>find方法：找到第一个满足条件的标签后立即返回，只返回一个元素（<strong>tag类型</strong>，<strong>但打印的时候显示的是字符串</strong>（会自动调用repr方法））<br>find_all 方法：找到所有满足条件的标签。然后返回一个列表</p>
<ol>
<li>find_all在提取标签的时候，第一个参数是标签的名字，如果想用标签属性进行过滤的时候</li>
<li>有些时候，不想提取这么多。那么可以使用limit参数</li>
</ol>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">&quot;a&quot;</span>, attrs=&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;link2&quot;</span>&#125;)</span><br><span class="line">soup.find_all(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;id&quot;</span>=<span class="string">&quot;link2&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>select 方法</strong><br>使用1方法可以方便的找出元素，但是有时候使用css选择器的方式可以更加方便。使用css选择器的语法，应该使用select方法。”.”表示查找”class”的属性，#表示查找id的属性。在规范的HTML中，相同的 <code>class</code> 可以出现在多个元素中，而一个 <code>id</code> 只能在一个元素中出现。</p>
<ol>
<li>通过标签名查找：<br><code>soup.select(&quot;a&quot;)</code></li>
<li>通过类名查找<br>通过类名，则应该在类的前面加一个<code>.</code><br><code>soup.select(&quot;&quot;.sister&quot;)</code></li>
<li>通过id查找：<br>通过id查找，则应该在id的名字前面加一个#号<br><code>soup.select(&quot;#link1&quot;)</code></li>
<li>组合查找。<ol>
<li>通过空格分开。会找到sister以内的所有子孙元素<br><code>soup.select(&quot;.sister #link1&quot;)</code><ol>
<li>通过 <code>&gt;</code> 分开。则只会找到sister的子元素</li>
<li>多个 <code>&gt;</code> 空格分开，可以查找对应的子元素</li>
</ol>
</li>
</ol>
</li>
<li>根据属性的名字进行查找：<br>应该先写标签名字。然后再在中括号中写属性的值<br><code>soup.select(input[name=&quot;name&quot;])</code><br>注意这里没有<font color='red'>@</font>, 与XPath区分一下。</li>
<li>在根据类名或者id进行查找的时候，如果还要根据标签名进行过滤。那么可以在类的前面或者id的前面加上标签名字：<br><code>soup.select(&quot;div.name&quot;)</code><br><code>soup.select(div#name)</code></li>
</ol>
</li>
</ol>
<p>TIPS: 详细的应用例子详见 代码</p>
<p><strong>Beautiful Soup 总结：</strong></p>
<ol>
<li><p><strong>四种对象：</strong></p>
<ol>
<li>Tag ： BeautifulSoup中所有的标签都是Tag类型。并且BeautifulSoup的对象本质上也是一个Tag类型。所以其实一些方法比如find，find_all并不是BeautifulSoup的。而是Tag的</li>
<li>NavigableString：继承自python中的str。用起来和python的str一样得</li>
<li>BeautifulSoup：继承自Tag。用来生成BeautifulSoup的。</li>
</ol>
</li>
<li><p>Comment：继承自NavigabelString</p>
</li>
<li><p><strong>contents和children：</strong></p>
<p>返回某个标签下的直接子元素。其中也包括字符串。<br>它们两个的区别是：contents返回来的是一个列表。children返回的是一个迭代器</p>
</li>
</ol>
<h3 id="三-正则表达式"><a href="#三-正则表达式" class="headerlink" title="三. 正则表达式"></a>三. 正则表达式</h3><p><strong>基本语法</strong></p>
<ol>
<li><code>re.match</code> 只能对字符串从头开始匹配，而<code>re.search</code> 能够对整个字符串进行匹配</li>
<li><code>.</code> 能够匹配除了<font color='red'>换行符</font>以外的任意一个字符</li>
<li><code>\d</code> 能够匹配任意一个数字，但<font color='red'>多位数</font>被认为含有多个数字，只会匹配第一个数字。如匹配 <code>18</code> 返回 <code>1</code> </li>
<li><code>\s</code> 能够匹配空白字符（\n，\t，\r，空格）</li>
<li><code>\w</code> 能够匹配 <code>a-z</code>,<code>A-Z</code>,数字和下划线</li>
<li><code>\W</code> 能够匹配 <code>/w</code> 匹配不到的字符，包括换行符等</li>
<li><code>[]</code> 只要满足中括号中的字符，就可以匹配。<code>[0-9]</code>表示匹配”0-9”的数字，而不是”0</li>
<li>“、”-“或”9”三个字符 。中括号中的 <code>^</code> 表示非</li>
</ol>
<p>具体案例</p>
<ol>
<li><p>验证手机号码：手机号码的规则是以 <code>1</code> 开头，第二位可以是 <code>34587</code>，后面那9位随意。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;18570631587&#x27;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;1[34587]\d&#123;9&#125;&#x27;</span>, text)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证邮箱：邮箱名称由 <code>字母、数字、下划线</code> 组成，然后是 <code>@</code> 符号，最后是域名。示例代码如下：</p>
</li>
</ol>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;tommyhechina@126.com&#x27;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;\w+@[0-9a-zA-Z]+\.[a-zA-Z]+&#x27;</span>, text)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>验证URL。URL的规则是前面是 <code>http</code>、<code>https</code> 或者 <code>ftp</code> ，然后加上 <code>:</code> ，然后加上 <code>//</code>，之后可以出现任意非空白字符。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;(http|https|ftp)://[^\s]+&#x27;</span>, text)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>验证身份证：身份证的规则是，总共有18位，前17位都是数字，最后一位可以是数字，也可以是小写的x，也可以是大写的X。示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;12345678901234567x&#x27;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;\d&#123;17&#125;[\d|x|X]&#x27;</span>, text)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>高级语法</strong>：</p>
<ol>
<li><code>^</code>（脱字号）：表示以…开始。如果在中括号中，表示取反操作</li>
<li><code>$</code> 表示以…结束。<code>$</code> 会识别左侧直接连接的非正则表达式字符串，或是一个正则表达式字符</li>
<li><code>|</code> 匹配多个表达式或字符串</li>
</ol>
<p>贪婪模式和非贪婪模式：贪婪模式尽可能多地匹配字符，非贪婪模式尽可能少地匹配字符。在正则表达式后加入 <code>?</code> 切换为非贪婪模式。在处理网页的时候，要注意切换为非贪婪模式</p>
<p>经典示例：</p>
<p>匹配0-100之间的数字，不允许出现09这样的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">&#x27;00&#x27;</span></span><br><span class="line">ret = re.match(<span class="string">&#x27;[1-9]\d?$|100$|0$&#x27;</span>, text)</span><br><span class="line">print(ret.group())</span><br></pre></td></tr></table></figure>

<p>转义字符和原生字符：在python和正则表达式中，<code>\</code> 均具有转义字符的含义，在正则表达式中使用原生字符串可以有效地降低复杂性，避免错误</p>
<p><strong>re模块中常用函数</strong></p>
<p>match：从开始的位置进行匹配。如果开始的位置没有匹配到，直接失败。</p>
<p>search：在字符串中寻找满足条件的字符。返回第一个满足条件的结果。</p>
<p>group：分组。可以使用<font color='red'>圆括号</font>对过滤得到的字符串进行分组。<code>group()</code> 等价于 <code>group(0)</code>，表示返回整个字符串；<code>groups</code> 返回里面的子组（以元组的形式），<font color='red'>索引从 <code>1</code> 开始</font>；<code>group(x)</code> 表示返回第 <code>x</code> 个子组；<code>group(x,y,z)</code> 表示返回第 <code>x</code>，<code>y</code>，<code>z</code>三个子组（以元组的形式）</p>
<p>findall：找出所有满足条件的字符，返回一个列表。如果在正则表达式中存在括号，则返回括号内的内容组成的列表</p>
<p>sub：将所有匹配到的字符串替换为其他字符串</p>
<p>split：使用匹配到的字符分割字符串，返回列表</p>
<p>compile：将常用的正则表达式进行编译，可以在多次访问中提高效率。尽量使用原生字符。引入re.VERBOSE参数可以输入多行的正则表达式以及添加注释。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫笔记——基础篇（一）</title>
    <url>/2020/08/16/%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="爬虫学习笔记"><a href="#爬虫学习笔记" class="headerlink" title="爬虫学习笔记"></a>爬虫学习笔记</h1><h2 id="第一章-网络请求"><a href="#第一章-网络请求" class="headerlink" title="第一章 网络请求"></a>第一章 网络请求</h2><h3 id="一-HTTP协议和chrome抓包工具"><a href="#一-HTTP协议和chrome抓包工具" class="headerlink" title="一. HTTP协议和chrome抓包工具"></a>一. HTTP协议和chrome抓包工具</h3><h3 id="什么是http和https协议："><a href="#什么是http和https协议：" class="headerlink" title="什么是http和https协议："></a>什么是http和https协议：</h3><p>​    HTTP协议：全称是HwperTextTransfer Protocol，中文意思是超文本传输协议，是一种发布和接收HTML页面的方法。服务器端口号是80端口。<br>​            HTTPS协议；是HTTP协议的加密版本，在HTTP下加入了SSL层，颜务器端口号是443端口。</p>
<h3 id="在浏览器中发送一个http请求的过程："><a href="#在浏览器中发送一个http请求的过程：" class="headerlink" title="在浏览器中发送一个http请求的过程："></a>在浏览器中发送一个http请求的过程：</h3><p>​            1.当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。<br>​            2.当我们在浏览器输入URL http:/<a href="http://www.baidu.com的时候,浏览器发送一个request请求去获取htp//www.baidu.com%E7%9A%84htm%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%8AResponse%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%8F%91%E9%80%81%E5%9B%9E%E7%BB%99%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%82">www.baidu.com的时候，浏览器发送一个Request请求去获取htp://www.baidu.com的htm文件，服务器把Response文件对象发送回给浏览器。</a><br>​            3.浏览器分析Response中的HTML，发现其中引用了很多其他文件，比如mages文件，CSS文件，JS文件。刻货器会自动再次发送Request去获取图片，CSS文件，或者JS文件。<br>​            4.当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。</p>
<h3 id="url详解"><a href="#url详解" class="headerlink" title="url详解"></a>url详解</h3><p>URL是Unifora Resource Locator的简写，统一资源定位符。一个URL由以下几部分组成：</p>
<p>​            <strong>schene://host:port/path/？query-string-xxx#anchor</strong></p>
<p>scheme：代表的是访问的协议，一般为http或者https以及代p等。<br>        host：主机名，域名，比如ww.baidu.com。<br>        port：端口号。当你访问一个网站的时候，浏览器默认使用80端口。<br>        path：查找路径。比如：ww.jianshu.com/trending/now，后面的trending/now 就是path。<br>        query-string：查询字符串，比如：wwr.baidu.con/s7we-python，后面的wd-oython 就是查询字符串。<br>        anchor：锚点，后台一般不用管，前端用来做页面定位的。<br>        在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值进行编码。</p>
<h3 id="常用的请求方法"><a href="#常用的请求方法" class="headerlink" title="常用的请求方法"></a>常用的请求方法</h3><p>在Http协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是set请求和post请求。<br>        1.get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用get 请求。<br>        2.post 请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。<br>以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用aet方法的请求就一定要改成post请求，这个要视情况而定。</p>
<h3 id="请求头常见参数"><a href="#请求头常见参数" class="headerlink" title="请求头常见参数"></a>请求头常见参数</h3><p>在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在ul中，第二个是把数据放在boay中（在post请求中），第三个就是把数据放在head中。这里介绍在网络虫中经常会用到的一些请求头参数：<br>        1.user-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种刻览器发送的。如果我们是通过爬虫发送请求，那么我们user-Agent 就是aythcn，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个植为一些浏览器的值，来伪装我们的爬虫。<br>        2.Referer；表明当前这个请求是从哪个ur1过来的。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。<br>        3.cookie:http 协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这时候就用cookie来做标识。一般如果想要做登录后才能访问的网站，那么就需要发送cookie信息了。</p>
<h3 id="常见响应状态码"><a href="#常见响应状态码" class="headerlink" title="常见响应状态码"></a>常见响应状态码</h3><p>1.200：请求正常，服务器正常的返回数据。<br>        2.301：永久重定向。比如在访问ww.jingdong.com的时候会重定向到ww.jc.com。<br>        3.302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。<br>        4.400：请求的ur1在服务器上找不到。换句话说就是请求ur1错误。<br>        5.403：服务器拒绝访问，权限不够。<br>        6.500：服务器内部错误。可能是服务器出现bug了。</p>
<h2 id="二-urllib库简单用法"><a href="#二-urllib库简单用法" class="headerlink" title="二. urllib库简单用法"></a>二. urllib库简单用法</h2><ul>
<li><p><code>request.urlopen()</code></p>
<p>ur1：请求的url。<br>data：请求的data，如果设置了这个值，那么将变成post请求。<br>返回值：返回值是一个http.client.HTTPResponse对象，这个对象是一个类文件句柄对象。<br>有read（size）、readline（读取一行）、readlines（读取多行）以及getcode(获取响应码) 等方法。</p>
</li>
<li><p><code>request.urlretrieve(网页的url, 下载名字)</code></p>
<pre><code>把网页上的一个文件保存到本地 </code></pre>
</li>
<li><p><code>parse.urlencode(key：value)</code><br>如果url有中文或者其他特殊字符，那么浏览器会自动给我们进行编码，但是通过爬虫来访问的时候，就必须用手动来进行编码。 这个方法可以将一个字典编码成key=value形式，且都用ascii码表示</p>
<p>例如：这个方法可以将中文编码成%0x形式表示=</p>
<p>tips：这种方法可以直接用 .encode() 方法代替。</p>
</li>
<li><p><code>parse.parse_qs()</code><br>这个相当于urlencode的反函数，解码</p>
</li>
<li><p><code>parse.urlparse()</code> 和 <code>parse.urlsplit()</code></p>
<p>顾名思义，这2个函数是对url进行解析</p>
<p>不同点，前者urlparse 会多返回一个params的属性参数。<br>这个params用的很少</p>
</li>
</ul>
<ul>
<li><p>request库中的Request类。  request.Request<br><strong>如果想要在请求的时候增加一些请求头，那么则必须使用request.Request类来实现</strong>。</p>
</li>
<li><p>ProxyHandler 处理器（代理设置）</p>
<ul>
<li>代理的原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，代理服务器拿到目的网站的数据后，再转发给我们的代码。</li>
<li><code>http://httpbin.org</code>：这个网站可以方便的查看http请求的一些参数</li>
</ul>
<p>很多网站会检测某一段时某个IP的访问次数（通过流量统计，系统日志等），如果访问次数多的不像正常人，它会禁止这个IP的访问。<br>所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。</p>
<p><strong>在代码中使用代理：</strong></p>
<pre><code>*使用“ur11ib.request.ProxyHandler”，传入一个代理，这个代理是一个字典，字典的key依赖于代理服务器能够接收的类型，一般是‘http或者https，值是ip:port&#39;
*使用上一步创建的“handler”，以request.build_opener”创建一个opener对象。
*使用上一步创建的opener，调用‘open’函数，发起请求。</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/ip&#x27;</span></span><br><span class="line"><span class="comment"># 用ProxyHandler传入代理构建一个handler</span></span><br><span class="line">handler=request.ProxyHandler(&#123;<span class="string">&quot;http&quot;</span>:<span class="string">&quot;27.43.190.180:9999&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># 使用上面创建的handler构建一个opener</span></span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line"><span class="comment"># 用opener去发送一个请求</span></span><br><span class="line">response = opener.open(url)</span><br><span class="line">print(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>常用的代理</strong></p>
<p>​        西刺免费代理IP:<code>http://www.xicidaili.com/</code><br>​        快代理：<code>http://www.kuaidaili.com/</code><br>​        代理云：<code>http://www.dailiyun.com/</code></p>
</li>
</ul>
<h3 id="什么是cookie："><a href="#什么是cookie：" class="headerlink" title="什么是cookie："></a>什么是cookie：</h3><p>在网站中，htp请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookte 存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie 只能存储一些小量的数据。</p>
<ul>
<li><p><strong>cookie的格式：</strong></p>
<p><code>Set-Cookie:NAME=VALUE:Expires/Max-age=DATE:Path=PATH:Domain-DOHAIN_NAUIE：SECURE</code></p>
</li>
</ul>
<p>  参数意义：<br>          NAME:cookie的名字。VALUE:cookie的值。<br>          Expires:cookie的过期时间。<br>          Path:cookie作用的路径。<br>          Domain:cookie作用的域名。<br>          SECURE：是否只在https协议下起作用。     </p>
<ul>
<li><strong>对Cookie的操作（基于urllib）</strong></li>
</ul>
<ol>
<li><p>cookielib库和HTTPCookieProcessor 模拟登陆</p>
<p>Cookie是指网站服务器为了辨别用户身份和进行session跟踪。而储存在用户浏览器上的文本文件，cookie可以保持登陆信息到用户等下次与服务器的session</p>
<ul>
<li><p>方法一：直接把网页登陆后的Cookie复制到请求头上传进去。</p>
</li>
<li><p><strong>方法二：爬虫自动登陆授权页面</strong></p>
<p>用到的模块：<strong>http.cookiejar模块</strong>和HTTPCookieProcessor</p>
<p>用到的类：<br><strong>CookieJar</strong>： 管理HTTP cookie值，存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie的对象。整个cookie都存储再内存中，对CookieJar实例进行垃圾回收后，cookie也将丢失<br><strong>FileCookieJar(filename, delayload=None, policy=None)**：由CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储在文件当中。filename是存储cookie的文件名。delayload为true时，支持延时访问文件，即只有在需要的时候猜读取文件或者再文件中存储数据<br>**MozilaCookieJar，LWPCookieJar</strong>：都是由FileCookieJar派生而来。不同点：格式与兼容有区别。主要用MozilaCookieJar 。该类创建与Mozila浏览器cookie.txt兼容的FileCookieJar实例。</p>
</li>
</ul>
</li>
<li><p>保存Cookie到本地<br>保存cookie到本地，可以使用cookiejar的sava函数，并且需要指定一个文件名。<br>然后对应还有一个load函数<br>这两个函数的ignore_discard参数是指 加载或者保存过期的cookie</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cookiejar = MozillaCookieJar(<span class="string">&quot;cookie.txt&quot;</span>) <span class="comment"># 火狐公司的cookie格式，文件名为cookie</span></span><br><span class="line">handler = request.HTTPCokkieProcessor(cookiejar)</span><br><span class="line">opener = request.build_opener(handler)</span><br><span class="line">headers = &#123;...&#125;</span><br><span class="line">req = request.Request(url, headers)</span><br><span class="line">resp = opener.open(req)</span><br><span class="line">print(resp.read())</span><br><span class="line">cookiejar.save(ignore_discard=<span class="literal">True</span>, ignore_expires=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python爬虫</tag>
      </tags>
  </entry>
</search>
